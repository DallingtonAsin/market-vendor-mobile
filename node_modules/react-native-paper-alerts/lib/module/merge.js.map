{"version":3,"sources":["merge.ts"],"names":["isObject","obj","Object","getPrototypeOf","prototype","toString","call","merge","objects","reduce","result","current","keys","forEach","key","Array","isArray","from","Set","concat"],"mappings":"AAQA;AACA,MAAMA,QAAQ,GAAIC,GAAD,IAAc;AAC7B,MAAI,OAAOA,GAAP,KAAe,QAAf,IAA2BA,GAAG,KAAK,IAAvC,EAA6C;AAC3C,QAAI,OAAOC,MAAM,CAACC,cAAd,KAAiC,UAArC,EAAiD;AAC/C,YAAMC,SAAS,GAAGF,MAAM,CAACC,cAAP,CAAsBF,GAAtB,CAAlB;AACA,aAAOG,SAAS,KAAKF,MAAM,CAACE,SAArB,IAAkCA,SAAS,KAAK,IAAvD;AACD;;AAED,WAAOF,MAAM,CAACE,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BL,GAA/B,MAAwC,iBAA/C;AACD;;AAED,SAAO,KAAP;AACD,CAXD;;AAaA,MAAMM,KAAK,GAAG,CAAsB,GAAGC,OAAzB,KACZA,OAAO,CAACC,MAAR,CAAe,CAACC,MAAD,EAASC,OAAT,KAAqB;AAClCT,EAAAA,MAAM,CAACU,IAAP,CAAYD,OAAZ,EAAqBE,OAArB,CAA8BC,GAAD,IAAS;AACpC,QAAIC,KAAK,CAACC,OAAN,CAAcN,MAAM,CAACI,GAAD,CAApB,KAA8BC,KAAK,CAACC,OAAN,CAAcL,OAAO,CAACG,GAAD,CAArB,CAAlC,EAA+D;AAC7DJ,MAAAA,MAAM,CAACI,GAAD,CAAN,GAAcC,KAAK,CAACE,IAAN,CAAW,IAAIC,GAAJ,CAAQR,MAAM,CAACI,GAAD,CAAN,CAAYK,MAAZ,CAAmBR,OAAO,CAACG,GAAD,CAA1B,CAAR,CAAX,CAAd;AACD,KAFD,MAEO,IAAId,QAAQ,CAACU,MAAM,CAACI,GAAD,CAAP,CAAR,IAAyBd,QAAQ,CAACW,OAAO,CAACG,GAAD,CAAR,CAArC,EAAqD;AAC1DJ,MAAAA,MAAM,CAACI,GAAD,CAAN,GAAcP,KAAK,CAACG,MAAM,CAACI,GAAD,CAAP,EAAcH,OAAO,CAACG,GAAD,CAArB,CAAnB;AACD,KAFM,MAEA;AACLJ,MAAAA,MAAM,CAACI,GAAD,CAAN,GAAcH,OAAO,CAACG,GAAD,CAArB;AACD;AACF,GARD;AAUA,SAAOJ,MAAP;AACD,CAZD,EAYG,EAZH,CADF;;AAeA,eAAeH,KAAf","sourcesContent":["interface IObject {\n  [key: string]: any;\n}\n\ntype TUnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\n  ? I\n  : never;\n\n// istanbul ignore next\nconst isObject = (obj: any) => {\n  if (typeof obj === 'object' && obj !== null) {\n    if (typeof Object.getPrototypeOf === 'function') {\n      const prototype = Object.getPrototypeOf(obj);\n      return prototype === Object.prototype || prototype === null;\n    }\n\n    return Object.prototype.toString.call(obj) === '[object Object]';\n  }\n\n  return false;\n};\n\nconst merge = <T extends IObject[]>(...objects: T): TUnionToIntersection<T[number]> =>\n  objects.reduce((result, current) => {\n    Object.keys(current).forEach((key) => {\n      if (Array.isArray(result[key]) && Array.isArray(current[key])) {\n        result[key] = Array.from(new Set(result[key].concat(current[key])));\n      } else if (isObject(result[key]) && isObject(current[key])) {\n        result[key] = merge(result[key], current[key]);\n      } else {\n        result[key] = current[key];\n      }\n    });\n\n    return result;\n  }, {}) as any;\n\nexport default merge;\n"]}